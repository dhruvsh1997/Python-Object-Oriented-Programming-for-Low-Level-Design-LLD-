# -*- coding: utf-8 -*-
"""BestPractices_OOPs_SOLID_Principles.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gTi5j_aOjs21SfgSjuD_8mqsUPtjXCHU
"""

#I need to learn Recurtion in Python before I start DSA using python, now In regression i have little knowledge about it and I can make small basic programms like factorial and febbonecci, but I need to learn it in an advance level so I easily identify where I need to stick with loop in a program or where its better to use recurtion and its better to use recurtion in this place for better time complexity and optimization. so guide me through the concepts I need to know for that and problems I need to solve for identify that level of recurtion prection. first I would Like to perfect my recurtion command on core python problems then advance python problems(including OOPs and decorators among other like SOLID), then I want to handle some problems using recurtion for day to day uses in ML and DL.

# üîÅ 1. Fundamental Recursion Concepts
# These are essential for understanding any recursive code.

# Concept	Description
# Base Case	Condition to terminate recursion. Prevents infinite calls.
# Recursive Case	The function calls itself with a smaller/simplified input.
# Call Stack	Under-the-hood mechanism that stores function calls (LIFO).
# Stack Overflow	Happens if base case is not hit ‚Üí too many calls on stack.
# Function Execution Flow	Understand how control moves during recursive calls.
# Multiple Recursions	One function making multiple recursive calls (e.g., tree traversal).
# Tree of Calls	Visualize recursion like a tree where each node is a call.

# üß† 2. Memory Management & Call Stack in Recursion
# Yes ‚Äî recursion has significant memory concepts:

# Concept	Description
# Call Stack Frame	Each recursive call creates a new memory frame with variables.
# Memory Complexity	Recursion uses extra space proportional to depth of recursion.
# Tail Recursion	A recursion where recursive call is the last operation. Optimizable in some languages (not Python).
# Recursion Limit	Python has a max depth (sys.getrecursionlimit()) to avoid infinite recursion.
# Memory Optimization	Use memoization or bottom-up (DP) to reduce memory use.
# Garbage Collection	Memory frames from returned calls are cleaned automatically in Python.

# üìå Python-specific note: Python does not do tail-call optimization, so even tail recursion grows the stack.

# üß© 3. Algorithmic Patterns Built on Recursion
# To solve advanced problems, you must recognize these patterns:

# Pattern	Example Problems
# Backtracking	N-Queens, Sudoku, Rat in Maze
# Divide & Conquer	Merge Sort, Quick Sort
# DFS (Tree/Graph)	Traversals, Path finding
# Combinatorial Recursion	Subsets, Permutations, Combinations
# Dynamic Programming	Memoization (Top-down), Tabulation (Bottom-up)
# Recursion with State	Path tracking, visited flags, rollback states

# üõ†Ô∏è 4. Python-Specific Recursive Techniques
# To use recursion well in Python:

# Concept	Why It Matters
# Lambda Recursion	Recursive anonymous functions, use Y-Combinator if needed.
# Decorators for Memoization	Use @lru_cache or custom memo decorators.
# Recursive Classes	Build recursive objects like Trees, Folders.
# Recursive Generators	Use yield with recursion for memory-efficient tree traversal.
# Recursive Decorators	Decorators that call recursively decorated functions.
# Handling sys.setrecursionlimit()	Know how to increase safely during deep recursions.

# üìê 5. Design-Level Concepts for OOP/Advanced Recursion
# Concept	Use
# Recursion in Class Methods	Used in custom Trees, ASTs, recursive data models
# Recursive Object Construction	Linked list, Tree, Graph
# Recursion with SOLID/OOP	Apply single responsibility, separation of concerns, etc., in recursive logic
# Decorator Pattern	Build recursive wrappers for logging, caching, etc.
# Recursion in Iterators	Implement __iter__ recursively to traverse nested structures

# ü§ñ 6. Recursion in ML, DL & Real-World Automation
# Concept	Application
# Recursive Tree Algorithms	Building Decision Trees, Expression Trees
# Recursive NN	Parsing Tree-based inputs (e.g., NLP tree parsing)
# Recursive Data Cleaning	Flattening nested dicts/lists, normalizing JSON/XML
# Recursive Regex or Tokenizer	For nested pattern matching
# Recursive Graph Traversal	Graph-based reasoning (e.g., dependencies, paths)
# Recursive Loop Unrolling in NumPy	Breaking large array operations recursively

# üß† Key Mental Models for Recursion
# Model	Use
# Recursion Tree	Trace execution and memory cost visually
# Stack Trace Model	Understand which function returns when
# State Restoration	Especially in backtracking, undoing decisions
# Memoization Table	For overlapping subproblem optimization

"""# OOPs in Python for Low-Level Design (LLD)
Object-Oriented Programming (OOP) is a programming paradigm that organizes code around "objects" rather than functions. In Python, OOP allows you to create classes (blueprints) and objects (instances) to model real-world entities, making code modular, reusable, and maintainable.

## Key Terminology and Why Use OOP in Python?
1. Modularity: Break code into manageable pieces (classes).
2. Reusability: Reuse classes across projects.
3. Maintainability: Easier to update and debug.
4. Scalability: Ideal for large systems like libraries or frameworks.

A. Class: Blueprint for objects, defining attributes (data) and methods (functions).<br>
B. Object: Instance of a class with its own state and behavior.<br>
C. Attribute: Variables belonging to a class or object.<br>
D. Method: Functions defined inside a class.<br>

## ‚úÖ **OOP Concepts Checklist**
- [x] Encapsulation
- [x] Abstraction
- [x] Inheritance (Single, Multi-Level, Multiple)
- [x] Polymorphism (Method Overriding, Operator Overloading)
- [x] Special Methods (__init__, __del__, etc.)
- [x] `@classmethod`, `@staticmethod`, `self`, `super()`
- [x] SOLID Principles in action

## 1. Encapsulation ‚Äî üîê Data Hiding
Encapsulation is about bundling data (attributes) and behavior (methods) into a class and restricting direct access.

Concept: Encapsulation bundles data and methods into a single unit (class) while restricting access to internal details. In Python, we use naming conventions like _ (protected) and __ (private) to indicate access levels.

Why It‚Äôs Useful: Protects data from unintended changes and ensures controlled access.

In LLD: Encapsulation is used to hide internal logic of components, making systems secure and modular.
"""

class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance  # private variable

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return amount
        return "Insufficient Funds"

    def get_balance(self):
        return self.__balance

# Usage
acc = BankAccount("Alice", 1000)
print(acc.get_balance())  # 1000
print(acc.withdraw(500))  # 500
print(acc.get_balance())  # 500
# print(acc.__balance)  # AttributeError (Encapsulation)
print(acc._BankAccount__balance)  # Calling Through Name Mangling (Encapsulation)

"""## 2. Abstraction ‚Äî üî¨ Hiding Implementation, Showing Functionality
Abstraction means showing only the essential details.
Concept: Abstraction hides complex implementation details and exposes only essential features. In Python, abstract classes (using the abc module) define interfaces that subclasses must implement.

Why It‚Äôs Useful: Simplifies code by focusing on what an object does, not how it does it.

In LLD: Abstraction defines clear interfaces for system components, ensuring flexibility and maintainability.
"""

from abc import ABC, abstractmethod

class PaymentMethod(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

class CreditCard(PaymentMethod):
    def __init__(self):
        self.bog=6783
    def pay(self, amount):
        print(f"Paid {amount} using Credit Card - {self.bog}")

class PayPal(PaymentMethod):
    def pay(self, amount):
        print(f"Paid {amount} using PayPal")

# Usage
p1 = CreditCard()
p1.pay(100)
p2 = PayPal()
p2.pay(250)

"""## 3. Inheritance ‚Äî üìù Code Reuse
Concept: Inheritance allows a subclass to inherit attributes and methods from a superclass. Python supports single, multiple, multilevel, and hierarchical inheritance.

Why It‚Äôs Useful: Promotes code reuse and establishes "is-a" relationships (e.g., a Car is a Vehicle).

In LLD: Used to model hierarchical relationships between components, reducing code duplication.

### Types:
- **Single**
- **Multilevel**
- **Multiple**
"""

# Single Inheritance
class Employee:
    def __init__(self, name):
        self.name = name

    def work(self):
        print(f"{self.name} is working")

class Developer(Employee):
    def work(self):
        print(f"{self.name} is coding")

vr = Developer("King Bob")
vr.work()

class Employee:
    def __init__(self, name):
        self.name = name

    def work(self):
        print(f"{self.name} is working")

class Developer(Employee):
    def work(self):
        print(f"{self.name} is coding")

# Multilevel Inheritance
class TechLead(Developer):
    def lead_team(self):
        print(f"{self.name} is leading the dev team")

# Usage
emp = TechLead("Alice")
emp.work()
emp.lead_team()

class Employee:
    def __init__(self, name):
        self.name = name

    def work(self):
        print(f"{self.name} is working")

class Developer(Employee):
    def work(self):
        print(f"{self.name} is coding")

class TechLead(Developer):
    def lead_team(self):
        print(f"{self.name} is leading the dev team")

# Multiple Inheritance
class Manager:
    def manage(self):
        print("Managing resources")

class DevManager(Developer, Manager):
    pass

dm = DevManager("Bob")
dm.work()
dm.manage()

"""## 4. Polymorphism ‚Äî ü§Ø Same Interface, Different Implementation
Concept: Polymorphism allows objects of different classes to be treated as instances of a common superclass, often through method overriding or operator overloading.

Why It‚Äôs Useful: Enables flexible and interchangeable components.

In LLD: Used to design systems where components can be swapped without changing the code.

### a. Method Overriding
"""

class Bird:
    def speak(self):
        print("Chirp")

class Parrot(Bird):
    def speak(self):
        print("I can talk!")

# Usage
b = Bird()
b.speak()
p = Parrot()
p.speak()

"""### b. Operator Overloading"""

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# Usage
v1 = Vector(2, 4)
v2 = Vector(1, 3)
print(v1 + v2)  # Vector(3, 7)

"""## 5. Special Methods: `__init__`, `__del__`, `__str__`"""

class Person:
    def __init__(self, name):
        self.name = name
        print(f"Person {self.name} created")

    def __del__(self):
        print(f"Person {self.name} deleted")

    def __str__(self):
        return f"Person: {self.name}"

p = Person("Charlie")
print(str(p))
del p

"""## 6. Class Method, Static Method, `self`, `super()`"""

class Logger:
    logs = []

    def __init__(self, message):
        self.message = message
        Logger.logs.append(message)

    @classmethod
    def get_logs(cls):
        return cls.logs

    @staticmethod
    def greet():
        print("Hello, this is Logger")

class AdvancedLogger(Logger):
    def __init__(self, message):
        super().__init__(message)
        print("Advanced Logger: ", message)

Logger.greet()
a = AdvancedLogger("Warning")
print(Logger.get_logs())

"""## 7. SOLID Principles
**S**: Single Responsibility Principle  
**O**: Open/Closed Principle  
**L**: Liskov Substitution Principle  
**I**: Interface Segregation Principle  
**D**: Dependency Inversion Principle  

### Example: Using SRP + DIP + OCP
"""

class EmailService:
    def send_email(self, to, content):
        print(f"Sending email to {to} with content: {content}")

class Notification:
    def __init__(self, sender):
        self.sender = sender

    def notify(self, to, msg):
        self.sender.send_email(to, msg)

# Usage
service = EmailService()
note = Notification(service)
note.notify("user@example.com", "Welcome!")

"""###1. Single Responsibility Principle (SRP)

Concept: A class should have only one reason to change, meaning it should have a single responsibility.

Why It‚Äôs Useful: Keeps classes focused, making them easier to maintain.

In LLD: Ensures each class handles one aspect of the system, improving modularity.
"""

class BankAccount:
    def __init__(self, balance=0):
        self._balance = balance

    def get_balance(self):
        return self._balance

class Transaction:
    @staticmethod
    def deposit(account, amount):
        if amount > 0:
            account._balance += amount
            return True
        return False

    @staticmethod
    def withdraw(account, amount):
        if 0 < amount <= account._balance:
            account._balance -= amount
            return True
        return False

# Usage
account = BankAccount(100)
Transaction.deposit(account, 50)
print(account.get_balance())  # Output: 150
print(Transaction.withdraw(account, 30))  # Output: True
print(account.get_balance())  # Output: 120

"""###2. Open-Closed Principle (OCP)

Concept: Classes should be open for extension but closed for modification.

Why It‚Äôs Useful: Allows adding new functionality without altering existing code.

In LLD: Enables scalable designs where new components can be added easily.
"""

from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class ShapeCalculator:
    @staticmethod
    def total_area(shapes):
        return sum(shape.area() for shape in shapes)

# Usage
shapes = [Circle(5), Rectangle(4, 5)]
total = ShapeCalculator.total_area(shapes)
print(total)  # Output: 98.5

"""###3. Liskov Substitution Principle (LSP)

Concept: Subclasses must be substitutable for their base classes without altering behavior.

Why It‚Äôs Useful: Ensures consistency in inheritance hierarchies.

In LLD: Guarantees that components can be swapped without breaking the system.
"""

class Vehicle:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def start(self):
        print(f"{self.make} {self.model} is starting.")

class Car(Vehicle):
    def __init__(self, make, model, year):
        super().__init__(make, model)  # Call superclass constructor
        self.year = year

    def drive(self):
        print(f"Driving the {self.year} {self.make} {self.model}.")

class ElectricCar(Car):
    def start(self):  # Override start method
        print(f"{self.make} {self.model} is starting silently.")

def test_car(car):
    car.start()
    car.drive()

# Usage
car = Car("Toyota", "Camry", 2022)
test_car(car)  # Output: Toyota Camry is starting. Driving the 2022 Toyota Camry.

electric_car = ElectricCar("Tesla", "Model S", 2023)
test_car(electric_car)  # Output: Tesla Model S is starting silently. Driving the 2023 Tesla Model S.

"""###4. Interface Segregation Principle (ISP)

Concept: Classes should not be forced to implement interfaces they don‚Äôt use.

Why It‚Äôs Useful: Reduces unnecessary dependencies, making code cleaner.

In LLD: Ensures components only implement relevant interfaces.
"""

from abc import ABC, abstractmethod

class AreaCalculable(ABC):
    @abstractmethod
    def area(self):
        pass

class PerimeterCalculable(ABC):
    @abstractmethod
    def perimeter(self):
        pass

class Circle(AreaCalculable, PerimeterCalculable):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

    def perimeter(self):
        return 2 * 3.14 * self.radius

# Usage
circle = Circle(5)
print(circle.area())  # Output: 78.5
print(circle.perimeter())  # Output: 31.4

"""###5. Dependency Inversion Principle (DIP)

Concept: High-level modules should depend on abstractions, not concrete implementations.

Why It‚Äôs Useful: Decouples modules, making systems more flexible.

In LLD: Allows swapping implementations without changing high-level logic.
"""



"""#Best Practices for OOP in Python
###To write professional and maintainable OOP code, follow these practices (Towards Data Science):
1. Meaningful Names: Use descriptive names (e.g., BankAccount instead of BA).
2. PEP 8 Compliance: Follow Python‚Äôs style guide (PEP 8).
3. Properties for Encapsulation: Use @property for controlled attribute access.
4. Abstract Base Classes: Use abc module for interfaces.
5. Composition Over Inheritance: Prefer composition for flexibility.
6. Exception Handling: Use try-except blocks for robustness.
7. Documentation: Add docstrings for clarity.
8. Type Hints: Use type hints for better code readability.
"""

class Employee:
    def __init__(self, name, salary):
        self._name = name
        self._salary = salary

    @property
    def salary(self):
        return self._salary

    @salary.setter
    def salary(self, value):
        if value >= 0:
            self._salary = value
        else:
            raise ValueError("Salary cannot be negative")

# Usage
emp = Employee("Alice", 50000)
print(emp.salary)  # Output: 50000
emp.salary = 60000
print(emp.salary)  # Output: 60000

"""###OOPs in Low Level Design (LLD)

In LLD, OOP is used to design the internal structure of systems, defining classes, their relationships, and interactions. According to GeeksforGeeks, LLD translates real-world problems into object-oriented solutions using OOP and SOLID principles.

###Design Patterns in LLD

Design patterns are reusable solutions to common problems. Examples include:





Singleton: Ensures one instance of a class.



Factory: Creates objects without specifying the exact class.



Observer: Notifies dependent objects of state changes.
"""

class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

# Usage
s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # Output: True

"""#UML Diagrams in LLD

UML diagrams visualize system design:





Class Diagrams: Show classes, attributes, methods, and relationships.



Sequence Diagrams: Illustrate object interactions over time.

[Vehicle]
- make
- model
+ start()

    ^
    |
[Car]
- year
+ drive()
"""

import time
from functools import wraps

class Timer:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start = time.time()
        result = self.func(*args, **kwargs)
        print(f"{self.func.__name__} took {time.time() - start} seconds")
        return result

@Timer
def slow_function():
    time.sleep(2)
    print("Slow function executed.")

# Usage
slow_function()  # Output: Slow function executed. slow_function took ~2.0 seconds

"""## Bonus: OOP in Decorator Projects & Pytest

### Decorator Pattern with OOP
"""

class Text:
    def render(self):
        return "Hello"

class BoldDecorator:
    def __init__(self, wrapped):
        self.wrapped = wrapped

    def render(self):
        return f"<b>{self.wrapped.render()}</b>"

# Usage
plain = Text()
bold = BoldDecorator(plain)
print(bold.render())  # <b>Hello</b>

import pytest

class Calculator:
    def add(self, a, b):
        return a + b

class TestCalculator:
    def test_add(self):
        calc = Calculator()
        assert calc.add(2, 3) == 5

# Run in Colab with: !pytest this_file.py

"""### OOP with Pytest Fixtures"""

# test_logger.py
class Logger:
    def __init__(self):
        self.logs = []

    def log(self, msg):
        self.logs.append(msg)

    def get_logs(self):
        return self.logs

# test_logger usage in pytest

def test_log():
    logger = Logger()
    logger.log("Error")
    assert logger.get_logs() == ["Error"]

